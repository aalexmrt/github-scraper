name: Build and Push Images

on:
  push:
    tags:
      - 'api-v*.*.*' # api-v1.2.3
      - 'commit-worker-v*.*.*' # commit-worker-v1.2.3
      - 'user-worker-v*.*.*' # user-worker-v1.2.3

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Extract service and version
        id: extract
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          # Extract service name and version from tag
          # api-v1.2.3 -> service=api, version=1.2.3 (builds all services)
          # commit-worker-v1.2.3 -> service=commit-worker, version=1.2.3
          # user-worker-v1.2.3 -> service=user-worker, version=1.2.3
          if [[ $TAG =~ ^api-v(.+)$ ]]; then
            echo "SERVICE=api" >> $GITHUB_OUTPUT
            echo "VERSION=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
            echo "BUILD_ALL=true" >> $GITHUB_OUTPUT
            echo "DOCKERFILE=backend/Dockerfile.prod" >> $GITHUB_OUTPUT
          elif [[ $TAG =~ ^commit-worker-v(.+)$ ]]; then
            echo "SERVICE=commit-worker" >> $GITHUB_OUTPUT
            echo "VERSION=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
            echo "BUILD_ALL=false" >> $GITHUB_OUTPUT
            echo "DOCKERFILE=backend/Dockerfile.cloudrun-commit-worker" >> $GITHUB_OUTPUT
          elif [[ $TAG =~ ^user-worker-v(.+)$ ]]; then
            echo "SERVICE=user-worker" >> $GITHUB_OUTPUT
            echo "VERSION=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
            echo "BUILD_ALL=false" >> $GITHUB_OUTPUT
            echo "DOCKERFILE=backend/Dockerfile.cloudrun-user-worker" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Error: Invalid tag format"
            exit 1
          fi

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure Docker
        run: |
          gcloud auth configure-docker ${{ secrets.GCP_REGION }}-docker.pkg.dev

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Verify package-lock.json exists
        run: |
          if [ ! -f backend/package-lock.json ]; then
            echo "‚ùå ERROR: package-lock.json is missing!"
            echo "   This file is required for reproducible builds."
            echo "   Please commit it: git add backend/package-lock.json && git commit -m 'Add package-lock.json'"
            exit 1
          fi
          echo "‚úÖ package-lock.json found"

      - name: Build and push images
        id: build
        run: |
          VERSION="${{ steps.extract.outputs.VERSION }}"
          BUILD_ALL="${{ steps.extract.outputs.BUILD_ALL }}"
          REGISTRY=${{ secrets.GCP_REGION }}-docker.pkg.dev/${{ secrets.PROJECT_ID }}/github-scraper

          # Define all services to build
          if [ "$BUILD_ALL" = "true" ]; then
            # Build all services when API tag is pushed
            SERVICES=("api:backend/Dockerfile.prod" "commit-worker:backend/Dockerfile.cloudrun-commit-worker" "user-worker:backend/Dockerfile.cloudrun-user-worker")
            echo "üî® Building all services (API, Commit Worker, User Worker) with version ${VERSION}..."
          else
            # Build only the specific service
            SERVICES=("${{ steps.extract.outputs.SERVICE }}:${{ steps.extract.outputs.DOCKERFILE }}")
            echo "üî® Building ${{ steps.extract.outputs.SERVICE }} with version ${VERSION}..."
          fi

          BUILT_SERVICES=()

          # Build each service
          for SERVICE_CONFIG in "${SERVICES[@]}"; do
            SERVICE_NAME=$(echo $SERVICE_CONFIG | cut -d: -f1)
            DOCKERFILE=$(echo $SERVICE_CONFIG | cut -d: -f2)
            IMAGE_TAG=${REGISTRY}/${SERVICE_NAME}:${VERSION}
            LATEST_TAG=${REGISTRY}/${SERVICE_NAME}:latest
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üì¶ Building ${SERVICE_NAME}:${VERSION}"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            docker buildx build \
              --platform linux/amd64 \
              -f ${DOCKERFILE} \
              --build-arg VERSION=${VERSION} \
              --cache-from type=registry,ref=${IMAGE_TAG} \
              --cache-from type=registry,ref=${LATEST_TAG} \
              -t ${IMAGE_TAG} \
              -t ${LATEST_TAG} \
              --push \
              --provenance=false \
              --sbom=false \
              ./backend
            
            BUILT_SERVICES+=("${SERVICE_NAME}")
            echo "‚úÖ ${SERVICE_NAME}:${VERSION} built and pushed"
          done

          # Output built services as JSON array for later steps
          echo "BUILT_SERVICES=$(IFS=','; echo "${BUILT_SERVICES[*]}")" >> $GITHUB_OUTPUT
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo ""
          echo "‚úÖ All images built and pushed successfully"

      - name: Verify images in registry
        run: |
          REGISTRY=${{ secrets.GCP_REGION }}-docker.pkg.dev/${{ secrets.PROJECT_ID }}/github-scraper
          EXPECTED_VERSION="${{ steps.build.outputs.VERSION }}"
          BUILT_SERVICES="${{ steps.build.outputs.BUILT_SERVICES }}"

          echo "üîç Verifying images in registry..."
          echo ""

          # Convert comma-separated string to array
          IFS=',' read -ra SERVICES <<< "$BUILT_SERVICES"

          for SERVICE_NAME in "${SERVICES[@]}"; do
            IMAGE_TAG=${REGISTRY}/${SERVICE_NAME}:${EXPECTED_VERSION}
            
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üîç Verifying ${SERVICE_NAME}:${EXPECTED_VERSION}"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            # Pull and verify APP_VERSION
            docker pull ${IMAGE_TAG}
            
            # Verify APP_VERSION is set
            APP_VERSION=$(docker inspect ${IMAGE_TAG} --format='{{range .Config.Env}}{{println .}}{{end}}' | grep "^APP_VERSION=" | cut -d= -f2 || echo "")
            
            if [ "$APP_VERSION" != "$EXPECTED_VERSION" ]; then
              echo "‚ùå ERROR: APP_VERSION mismatch for ${SERVICE_NAME}!"
              echo "   Expected: ${EXPECTED_VERSION}"
              echo "   Found: ${APP_VERSION:-not set}"
              exit 1
            fi
            echo "‚úÖ APP_VERSION verified: ${APP_VERSION}"
            
            # Verify node_modules exists (quick check)
            if ! docker run --rm --platform linux/amd64 --entrypoint /bin/sh ${IMAGE_TAG} -c "test -d /app/node_modules && test -f /app/node_modules/.bin/prisma" 2>/dev/null; then
              echo "‚ùå ERROR: Critical dependencies missing in ${SERVICE_NAME} image!"
              echo "   Checking what's in /app:"
              docker run --rm --platform linux/amd64 --entrypoint /bin/sh ${IMAGE_TAG} -c "ls -la /app" || true
              exit 1
            fi
            echo "‚úÖ Dependencies verified: node_modules, prisma present"
            echo ""
          done

          echo "‚úÖ All images verified successfully"

      - name: Cleanup old images
        if: success() # Only run if build succeeded
        run: |
          # Cleanup old images for all built services
          export PROJECT_ID=${{ secrets.PROJECT_ID }}
          export REGION=${{ secrets.GCP_REGION }}
          export REPOSITORY=github-scraper
          BUILT_SERVICES="${{ steps.build.outputs.BUILT_SERVICES }}"

          # Convert comma-separated string to array
          IFS=',' read -ra SERVICES <<< "$BUILT_SERVICES"

          for SERVICE_NAME in "${SERVICES[@]}"; do
            echo "üßπ Cleaning up old images for ${SERVICE_NAME}..."
            ./scripts/utils/cleanup-old-images.sh ${SERVICE_NAME} --execute || echo "‚ö†Ô∏è  Cleanup failed for ${SERVICE_NAME}, continuing..."
          done
        continue-on-error: true # Don't fail workflow if cleanup fails

      - name: Trigger deployments in infra repo
        run: |
          # Automatically trigger deployment in infra repo for all built services
          BUILT_SERVICES="${{ steps.build.outputs.BUILT_SERVICES }}"
          VERSION="${{ steps.build.outputs.VERSION }}"

          # Convert comma-separated string to array
          IFS=',' read -ra SERVICES <<< "$BUILT_SERVICES"

          for SERVICE_NAME in "${SERVICES[@]}"; do
            echo "üöÄ Triggering deployment for ${SERVICE_NAME}:${VERSION}..."
            curl -X POST https://api.github.com/repos/aalexmrt/github-scraper-infra/dispatches \
              -H "Authorization: token ${{ secrets.DEPLOY_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -d "{
                \"event_type\":\"deploy\",
                \"client_payload\":{
                  \"service\":\"${SERVICE_NAME}\",
                  \"version\":\"${VERSION}\"
                }
              }"
            echo "‚úÖ Deployment triggered for ${SERVICE_NAME}:${VERSION}"
          done

          echo ""
          echo "‚úÖ All deployments triggered successfully"
